%!PS

% Barcode Writer in Pure PostScript - Version 2017-06-25
% http://bwipp.terryburton.co.uk
%
% Copyright (c) 2004-2017 Terry Burton
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

%%BeginResource: Category uk.co.terryburton.bwipp 0.0 2017062500 29629 32838
%%BeginData:          6 ASCII Lines
currentglobal
true setglobal
/Generic /Category findresource dup length 1 add dict copy dup
/InstanceType /setpacking where {pop /packedarraytype} {/arraytype} ifelse put
/uk.co.terryburton.bwipp exch /Category defineresource pop
setglobal
%%EndData
%%EndResource

%%BeginResource: uk.co.terryburton.bwipp raiseerror 0.0 2017062500 153516 39847
%%BeginData:         13 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/raiseerror {
  $error exch /errorinfo exch put
  $error exch /errorname exch put
  $error /command null put
  $error /newerror true put
  stop
} bind def
/raiseerror dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource

%%BeginResource: uk.co.terryburton.bwipp renmatrix 0.0 2017062500 106432 105425
%%BeginData:        309 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
begin
/renmatrix {

    20 dict begin

    /args exch def

    % Default options
    /width 1 def
    /height 1 def
    /barcolor (unset) def
    /backgroundcolor (unset) def
    /inkspread 0 def
    /inkspreadh 0 def
    /inkspreadv 0 def
    /includetext false def
    /txt [] def
    /textcolor (unset) def
    /textxalign (unset) def
    /textyalign (unset) def
    /textfont (Courier) def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset 0 def
    /textgaps 0 def
    /alttext () def

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall

    /width width cvr def
    /height height cvr def
    /barcolor barcolor cvlit def
    /backgroundcolor backgroundcolor cvlit def
    /inkspread inkspread cvr def
    /inkspreadh inkspreadh cvr def
    /inkspreadv inkspreadv cvr def
    /textcolor textcolor cvlit def
    /textxalign textxalign cvlit def
    /textyalign textyalign cvlit def
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /textgaps textgaps cvr def
    /alttext alttext cvlit def

    inkspread 0 ne {/inkspreadh inkspread def} if
    inkspread 0 ne {/inkspreadv inkspread def} if

    /xyget      { pixx mul add pixs exch get                   } bind def
    /xyinvert   { pixx mul add pixs exch 2 copy get 1 xor put  } bind def
    /mxyget     { pixx mul add m exch get 2#001 and            } bind def
    /mxyset     { pixx mul add m exch 3 -1 roll put            } bind def
    /msetborder { pixx mul add m exch 2 copy get 2#010 or put  } bind def
    /mborderoff { pixx mul add m exch 2 copy get 2#100 or put  } bind def
    /misborder  { pixx mul add m exch get 2#110 and 2#010 eq   } bind def
    /mclear     { pixx mul add m exch 2 copy get 2#001 and put } bind def
    /mclear4 {
        2 copy                       mclear
        2 copy 1 add                 mclear
        2 copy exch 1 add exch       mclear
        2 copy exch 1 add exch       mclear
               1 add exch 1 add exch mclear
    } bind def

    /trace {
        % Walk the outline of a region emitting edge coordinates of the path
        /y exch def  /x exch def
        % dir 0:right 1:down 2:left 3:up
        % hug 0:right 1:left
        /dir x 1 add y 1 add mxyget def  /hug dir def
        /sx x def  /sy y def  /sdir dir def
        mark [x y] {
            x 1 add y
            x 1 add y 1 add
            x       y 1 add
            x       y
            8 dir 2 mul neg roll
            /Dy exch def  /Dx exch def  /D Dx Dy xyget def
            /Cy exch def  /Cx exch def  /C Cx Cy xyget def
            /By exch def  /Bx exch def  /B Bx By xyget def
            /Ay exch def  /Ax exch def  /A Ax Ay xyget def
            A B eq {
                A C eq {/L} {/R} ifelse
            } {
                A C eq B D eq and {
                    A 0 eq hug 0 eq xor {/R} {/F} ifelse
                } {
                    /F
                } ifelse
            } ifelse
            dup /F eq {
                pop
                dir 0 eq {/x x 1 add def} if
                dir 1 eq {/y y 1 add def} if
                dir 2 eq {/x x 1 sub def} if
                dir 3 eq {/y y 1 sub def} if
                hug 0 eq {
                    Ax Ay msetborder
                } {
                    Bx By msetborder
                } ifelse
            } {
                /L eq {
                    /dir dir 3 add 4 mod def
                    hug 1 eq {
                         Bx By msetborder
                         Dx Dy mborderoff
                    } if
                } {  % R
                    /dir dir 1 add 4 mod def
                    hug 0 eq {
                         Ax Ay msetborder
                         Cx Cy mborderoff
                    } if
                } ifelse
                [x y]
            } ifelse
            x sx eq y sy eq and dir sdir eq and {exit} if
        } loop
        counttomark array astore exch pop

        % Invert the interior of the path
        /x x 1 add def /y y 1 add def
        /t x y mxyget 1 xor def
        mark x y {
            counttomark 0 eq {exit} if
            /y exch def /x exch def
            x y mxyget t ne {
                0          x 1 sub -1 0          {dup y misborder {exch pop exit} if pop} for
                pixx 1 sub x 1 add  1 pixx 1 sub {dup y misborder {exch pop exit} if pop} for
                1 exch {  % From left to right border
                    /i exch def
                    i y misborder not {
                        t i y mxyset
                        i y xyinvert
                    } if
                    i y 1 sub mxyget t ne i y 1 sub misborder not and {i y 1 sub} if
                    i y 1 add mxyget t ne i y 1 add misborder not and {i y 1 add} if
                } for
            } if
        } loop
        pop

        % Walk the path to clear the border information
        dup 0 get aload pop /y1 exch def /x1 exch def
        dup dup length 1 sub 1 exch getinterval {
            aload pop /y2 exch def /x2 exch def
            x2 x1 gt { x1  2 x2 1 sub {y1      mclear4} for } if
            y2 y1 gt { y1  2 y2 1 sub {x1 exch mclear4} for } if
            x2 x1 lt { x1 -2 x2 1 add {y1      mclear4} for } if
            y2 y1 lt { y1 -2 y2 1 add {x1 exch mclear4} for } if
            /x1 x2 def /y1 y2 def
        } forall

        % Discard duplicate final point
        dup length 1 sub 0 exch getinterval

    } bind def

    % Pad the bitmap on all sides
    /pixs [
        pixx 2 add {0} repeat
        0 pixx pixs length 1 sub {
            0 exch
            pixs exch pixx getinterval aload pop
            0
        } for
        pixx 2 add {0} repeat
    ] def
    /pixx pixx 2 add def
    /pixy pixy 2 add def

    % Track inverted regions and working space
    /m [ pixs length {0} repeat ] def

    % Construct paths by tracing and inverting each dark region
    /paths [
        0 1 pixy 1 sub {
            /j exch def
            0 1 pixx 1 sub {
                /i exch def
                i j xyget 1 eq {
                    i 1 sub j 1 sub trace
                } if
            } for
        } for
    ] def

    % Revert the bitmap size
    /pixx pixx 2 sub def
    /pixy pixy 2 sub def

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    gsave

    % Draw the image
    /inkspreadh inkspreadh 2 div def
    /inkspreadv inkspreadv 2 div def
    currentpoint translate
    width pixx div 72 mul height pixy div 72 mul scale
    0 0 moveto pixx 0 lineto pixx pixy lineto 0 pixy lineto closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if
    barcolor (unset) ne { barcolor setanycolor } if
    newpath
    paths {
        /p exch def
        /len p length def
        p len 1 sub get aload pop
        p 0 get aload pop
        0 1 len 1 sub {                                % x1 y1 x2 y2
            /i exch def
            p i 1 add len mod get aload pop 6 -2 roll  % x3 y3 x1 y1 x2 y2
            5 index inkspreadh
            4 index 4 -1 roll lt {add} {sub} ifelse    % y3<y1 ? x2+i : x2-i
            4 1 roll
            4 index inkspreadv
            4 index 4 -1 roll gt {add} {sub} ifelse    % x3>x1 ? y2+i : y2-i
            4 -1 roll exch pixy exch sub
            i 0 eq {moveto} {lineto} ifelse
        } for                                          % x2 y2 x3 y3
        closepath
        pop pop pop pop
    } forall
    fill

    % Display the text for elements in the text array
    textcolor (unset) ne { textcolor setanycolor } if
    includetext {
        textxalign (unset) eq textyalign (unset) eq and alttext () eq and {
            /s 0 def /fn () def
            txt {
                {} forall
                2 copy s ne exch fn ne or {
                    2 copy /s exch def /fn exch def
                    selectfont
                } {
                    pop pop
                } ifelse
                moveto show
            } forall
        } {
            textfont textsize selectfont
            alttext () eq {
                /txt [ txt { 0 get {} forall } forall ] def
                /tstr txt length string def
                0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for
            } {
                /tstr alttext def
            } ifelse

            % Find true ascent of font
            tstr length 0 eq {
                0
            } {
                gsave
                newpath 0 0 moveto (0) false charpath pathbbox
                4 1 roll pop pop pop
                grestore
                currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse
                currentfont /StrokeWidth known and {
                    currentfont /StrokeWidth get 2 div 0 exch
                    currentfont /FontMatrix get dtransform
                    dup mul exch dup mul add sqrt
                    add
                } if
            } ifelse
            /textascent exch def
            /textwidth tstr stringwidth pop tstr length 1 sub textgaps mul add def

            /textxpos textxoffset x textwidth sub 2 div add def
            textxalign (left) eq { /textxpos textxoffset def } if
            textxalign (right) eq { /textxpos x textxoffset sub textwidth sub def } if
            textxalign (offleft) eq { /textxpos textwidth textxoffset add neg def } if
            textxalign (offright) eq { /textxpos x textxoffset add def } if
            textxalign (justify) eq textwidth x lt and {
                /textxpos 0 def
                /textgaps x textwidth sub tstr length 1 sub div def
            } if
            /textypos textyoffset textascent add 1 add neg def
            textyalign (above) eq { /textypos textyoffset pixy add 1 add def } if
            textyalign (center) eq { /textypos textyoffset pixy textascent sub 2 div add def } if
            textxpos textypos moveto textgaps 0 tstr ashow
        } ifelse
    } if

    grestore

    end

} bind def
/renmatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource

%%BeginResource: uk.co.terryburton.bwipp dotcode 0.0 2017062500 282290 294383
%%BeginData:        958 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/dotcode {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /rows -1 def
    /columns -1 def
    /ratio -1 def
    /parse false def
    /parsefnc false def
    /raw false def
    /fast false def
    /mask -1 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /rows rows cvi def
    /columns columns cvi def
    /ratio ratio cvr def
    /mask mask cvi def

    % Set the ratio to 3:2 if no size is specified
    ratio -1 eq rows -1 eq and columns -1 eq and {
        /ratio 3 2 div def
    } if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters
    /laa  -1 def  /lab  -2 def  /lac  -3 def  /bin  -4 def
    /sfa  -5 def  /sfb  -6 def  /sb2  -7 def  /sb3  -8 def
    /sb4  -9 def  /sb5 -10 def  /sb6 -11 def  /sfc -12 def
    /sc2 -13 def  /sc3 -14 def  /sc4 -15 def  /sc5 -16 def
    /sc6 -17 def  /sc7 -18 def  /bsa -19 def  /bsb -20 def
    /tma -21 def  /tmb -22 def  /tmc -23 def  /tms -24 def
    /fn1 -25 def  /fn2 -26 def  /fn3 -27 def  /crl -28 def
    /aim -29 def  /m05 -30 def  /m06 -31 def  /m12 -32 def
    /mac -33 def

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ sfb  crl  (96) ]  [ sb2    9  (97) ]  [ sb3   28  (98) ]  % 96-98
      [ sb4   29  (99) ]  [ sb5   30  aim  ]  [ sb6  sfa  laa  ]  % 99-101
      [ lab  laa  sfb  ]  [ sc2  sc2  sb2  ]  [ sc3  sc3  sb3  ]  % 102-104
      [ sc4  sc4  sb4  ]  [ lac  lac  lab  ]  [ fn1  fn1  fn1  ]  % 105-107
      [ fn2  fn2  fn2  ]  [ fn3  fn3  fn3  ]  [ bsa  bsa  bsa  ]  % 108-110
      [ bsb  bsb  bsb  ]  [ bin  bin  bin  ]                      % 111-112
    ] def

    % Invert charmaps to give character to value maps for each state
    /charvals [ 113 dict 117 dict 113 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put
        } for
    } for
    /Avals charvals 0 get def
    /Bvals charvals 1 get def
    Bvals m05  97 put
    Bvals m06  98 put
    Bvals m12  99 put
    Bvals mac 100 put
    /Cvals charvals 2 get def
    /BINvals <<
        102 [ sc2 sc3 sc4 sc5 sc6 sc7 tma tmb tmc tms ] {exch 1 add dup} forall pop
    >> def

    /fncvals <<
        (FNC1) fn1
        (FNC2) fn2
        (FNC3) fn3
    >> def
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    % Pre-compute properties of the input at each point
    /nDigits      [ msglen 1 add {0} repeat     ] def
    /SeventeenTen [ msglen 1 add {false} repeat ] def
    /ECI          [ msglen 1 add {false} repeat ] def
    /DatumA       [ msglen 1 add {false} repeat ] def
    /DatumB       [ msglen 1 add {false} repeat ] def
    /DatumC       [ msglen 1 add {false} repeat ] def
    /Binary       [ msglen 8 add {false} repeat ] def
    /AheadC       [ msglen 1 add {0} repeat     ] def
    /TryC         [ msglen 1 add {0} repeat     ] def
    /AheadA       [ msglen 1 add {0} repeat     ] def
    /AheadB       [ msglen 1 add {0} repeat     ] def
    /UntilEndSeg  [ msglen 1 add {0} repeat     ] def
    msglen 1 sub -1 0 {
        /i exch def
        /barchar msg i get def
        barchar 48 ge barchar 57 le and {
            nDigits i nDigits i 1 add get 1 add put
        } if
        Avals barchar known {DatumA i true put} if
        Bvals barchar known {DatumB i true put} if
        /CRLF false def
        barchar 13 eq i msglen 1 sub lt and {
            msg i 1 add get 10 eq {/CRLF true def} if
        } if
        CRLF {DatumB i true put} if
        nDigits i get 2 ge  {DatumC i true put} if
        barchar 0 lt        {DatumC i true put} if  % FNCx
        barchar 128 ge      {Binary i true put} if
        nDigits i get 10 ge {  % 17xxxxxx10
            mark
            msg i 10 getinterval aload pop
            1 {  % common exit
                48 ne {false exit} if
                49 ne {false exit} if
                pop pop pop pop pop pop
                55 ne {false exit} if
                49 ne {false exit} if
                true
            } repeat
            SeventeenTen i 3 -1 roll put
            cleartomark
        } if
        nDigits i 1 add get 6 ge msg i get fn2 eq and {  % ^FNC2xxxxxx
            ECI i true put
        } if
        barchar 0 lt {  % FNCx
            AheadC i AheadC i 1 add get 1 add put
        } {
            nDigits i get 1 le {
                AheadC i 0 put
            } {
                AheadC i AheadC i 2 add get 1 add put
            } ifelse
        } ifelse
        nDigits i get 0 gt AheadC i get AheadC i 1 add get gt and {
            TryC i AheadC i get put
        } if
        DatumA i get TryC i get 2 lt and {
            AheadA i AheadA i 1 add get 1 add put
        } if
        DatumB i get TryC i get 2 lt and {
            AheadB i AheadB i 1 add CRLF {1 add} if get 1 add put
        } if
        barchar fn3 ne {
            UntilEndSeg i UntilEndSeg i 1 add get 1 add put
        } if
    } for

    /A 0 def  /B 1 def  /C 2 def  /BIN 3 def

    /addtocws {
        dup cws exch j exch putinterval
        /j exch length j add def
    } bind def

    % Base 259 to one more in base 103
    /base259to103 {
        /in exch def
        /inlen in length def
        /in [ 5 inlen sub {0} repeat in aload pop ] def
        /out 6 array def
        /msbs [ in 0 2 getinterval aload pop ] def
        /mscs [
            msbs aload pop exch 259 mul add
            2 {dup 103 mod exch 103 idiv} repeat
        ] def
        /lsbs [ in 2 3 getinterval aload pop ] def
        /lscs [
            lsbs aload pop exch 259 mul add exch 67081 mul add
            3 {dup 103 mod exch 103 idiv} repeat
        ] def
        lscs 0 get mscs 0 get 42 mul add
        out 5 2 index 103 mod put
        103 idiv lscs 1 get add mscs 0 get 68 mul add mscs 1 get 42 mul add
        out 4 2 index 103 mod put
        103 idiv lscs 2 get add mscs 0 get 92 mul add mscs 1 get 68 mul add mscs 2 get 42 mul add
        out 3 2 index 103 mod put
        103 idiv lscs 3 get add mscs 0 get 15 mul add mscs 1 get 92 mul add mscs 2 get 68 mul add
        out 2 2 index 103 mod put
        103 idiv mscs 1 get 15 mul add mscs 2 get 92 mul add
        out 1 2 index 103 mod put
        103 idiv mscs 2 get 15 mul add
        out 0 3 -1 roll 103 mod put
        out 6 inlen sub 1 sub inlen 1 add getinterval
    } bind def

    /finaliseBIN {
        bpos 0 ne {
            bvals 0 bpos getinterval base259to103 aload pop
            /bpos 0 def
        } if
    } bind def

    /addtobin {
        bvals exch bpos exch put
        /bpos bpos 1 add def
        bpos 5 eq { finaliseBIN } if
    } bind def

    /ECIabc {  % ECI encoding for modes A, B and C
        msg i 1 add 6 getinterval 0 exch {48 sub add 10 mul} forall 10 idiv
        dup 40 ge {
            40 sub
            dup 12769 idiv 40 add exch 12769 mod
            dup   113 idiv        exch   113 mod
        } if
    } bind def

    /ECIbin {  % ECI encoding for binary mode
        [
            msg i 1 add 6 getinterval 0 exch {48 sub add 10 mul} forall 10 idiv
            dup 65536 ge {
                258 exch dup 65536 idiv exch 65536 mod dup 256 idiv exch 256 mod
            } {
                dup 256 ge {
                    257 exch dup 256 idiv exch 256 mod
                } {
                    256 exch
                } ifelse
            } ifelse
        ] {
            addtobin
        } forall
    } bind def

    /encC {
        1 {  % Common exit
            i segstart eq {  % Structured data macros
                1 {  % common exit
                    i segend 7 sub gt {0 exit} if
                    msg segstart       get 91 ne {0 exit} if                    % [
                    msg segstart 1 add get 41 ne {0 exit} if                    % )
                    msg segstart 2 add get 62 ne {0 exit} if                    % >
                    msg segstart 3 add get 30 ne {0 exit} if                    % {RS}
                    msg segstart 4 add get dup 48 lt exch 57 gt or {0 exit} if  % digit
                    msg segstart 5 add get dup 48 lt exch 57 gt or {0 exit} if  % digit
                    msg segend   1 sub get  4 ne {0 exit} if                    % End: {EOT}
                    msg segstart 4 add get 48 sub 10 mul msg segstart 5 add get 48 sub add
                    dup dup 05 ne exch dup 06 ne exch 12 ne and and {pop mac exit} if
                    msg segstart 6 add get 29 ne {pop 0 exit} if                % {GS}
                    msg segend   2 sub get 30 ne {pop 0 exit} if                % End: {RS}
                    dup 05 eq {pop m05 exit} if
                        06 eq {    m06 exit} if
                                   m12 exit
                } repeat
                /inmac exch def
                inmac 0 ne {
                    /mode B def
                    [ Bvals inmac get ] addtocws
                    /i i inmac mac ne {7} {6} ifelse add def
                    exit
                } if
            } if
            SeventeenTen i get {
                [  % 17xxxxxx10 macro
                    Cvals aim get
                    msg i 2 add get 48 sub 10 mul msg i 3 add get 48 sub add
                    msg i 4 add get 48 sub 10 mul msg i 5 add get 48 sub add
                    msg i 6 add get 48 sub 10 mul msg i 7 add get 48 sub add
                ] addtocws
                /i i 10 add def
                exit
            } if
            DatumC i get {
                msg i get dup fn1 eq exch dup fn2 eq exch fn3 eq or or {  % FNCx
                    [ Cvals msg i get get ] addtocws
                    ECI i get {  % FNC2 then 6 digits
                        [ ECIabc ] addtocws
                        /i i 7 add def
                        exit
                    } if
                    msg i get fn3 eq segstart i ne and {  % FNC3
                        /i i 1 add def
                        /inmac 0 def
                        /segstart i def
                        /segend i UntilEndSeg i get add def
                        exit
                    } if
                    /i i 1 add def
                    exit
                } if
                [ msg i get 48 sub 10 mul msg i 1 add get 48 sub add ] addtocws
                /i i 2 add def
                exit
            } if
            Binary i get {  % Binary
                nDigits i 1 add get 0 gt {
                    msg i get 160 lt {
                        [ Cvals bsa get Avals msg i get 128 sub get ] addtocws
                    } {
                        [ Cvals bsb get Bvals msg i get 128 sub get ] addtocws
                    } ifelse
                    /i i 1 add def
                    exit
                } if
                [ Cvals bin get ] addtocws
                /mode BIN def
                exit
            } if
            /m AheadA i get def  /n AheadB i get def
            m n gt {
                [ Cvals laa get ] addtocws
                /mode A def
                exit
            } if
            i segstart eq {
                msg i get dup 9 eq exch dup 28 eq exch dup 29 eq exch 30 eq or or or {
                    [ Cvals laa get ] addtocws
                    /mode A def
                    exit
                } if
            } if
            n 4 gt {
                [ Cvals lab get ] addtocws
                /mode B def
                exit
            } if
            [ Cvals [ sfb sb2 sb3 sb4 ] n 1 sub get get ] addtocws
            n {
                [ Bvals msg i get get ] addtocws
                /i i 1 add def
            } repeat
            exit
        } repeat
    } bind def  % encC

    /encB {
        1 {  % Common exit
            /n TryC i get def
            n 2 ge {
                n 4 gt {
                    [ Bvals lac get ] addtocws
                    /mode C def
                    exit
                } if
                [ Bvals [ sfc sc2 sc3 sc4 ] n 1 sub get get ] addtocws
                n {
                    msg i get 0 lt {
                        [ Cvals msg i get get ] addtocws
                        /i i 1 add def
                    } {
                        [ msg i get 48 sub 10 mul msg i 1 add get 48 sub add ] addtocws
                        /i i 2 add def
                    } ifelse
                } repeat
                exit
            } if
            DatumB i get {
                msg i get dup fn1 eq exch dup fn2 eq exch fn3 eq or or {  % FNCx
                    [ Bvals msg i get get ] addtocws
                    ECI i get {  % FNC2 then 6 digits
                        [ ECIabc ] addtocws
                        /i i 7 add def
                        exit
                    } if
                    msg i get fn3 eq i segstart ne and {  % FNC3
                        /i i 1 add def
                        /mode C def
                        /inmac 0 def
                        /segstart i def
                        /segend i UntilEndSeg i get add def
                        exit
                    } if
                    /i i 1 add def
                    exit
                } if
                msg i get 13 eq i msglen 1 sub lt and {
                    msg i 1 add get 10 eq {  % CRLF
                        [ Bvals crl get ] addtocws
                        /i i 2 add def
                        exit
                    } if
                } if
                [ Bvals msg i get get ] addtocws
                /i i 1 add def
                exit
            } if
            Binary i get {  % Binary
                DatumB i 1 add get {
                    msg i get 160 lt {
                        [ Bvals bsa get Avals msg i get 128 sub get ] addtocws
                    } {
                        [ Bvals bsb get Bvals msg i get 128 sub get ] addtocws
                    } ifelse
                    /i i 1 add def
                    exit
                } if
                [ Bvals bin get ] addtocws
                /mode BIN def
                exit
            } if
            AheadA i get 1 eq {
                [ Bvals sfa get Avals msg i get get ] addtocws
                /i i 1 add def
                exit
            } if
            [ Bvals laa get ] addtocws
            /mode A def
            exit
        } repeat
    } bind def

    /encA {
        1 {  % Common exit
            /n TryC i get def
            n 2 ge {
                n 4 gt {
                    [ Avals lac get ] addtocws
                    /mode C def
                    exit
                } if
                [ Avals [ sfc sc2 sc3 sc4 ] n 1 sub get get ] addtocws
                n {
                    msg i get 0 lt {
                        [ Cvals msg i get get ] addtocws
                        /i i 1 add def
                    } {
                        [ msg i get 48 sub 10 mul msg i 1 add get 48 sub add ] addtocws
                        /i i 2 add def
                    } ifelse
                } repeat
                exit
            } if
            DatumA i get {
                msg i get dup fn1 eq exch dup fn2 eq exch fn3 eq or or {  % FNCx
                    [ Avals msg i get get ] addtocws
                    ECI i get {  % FNC2 then 6 digits
                        [ ECIabc ] addtocws
                        /i i 7 add def
                        exit
                    } if
                    msg i get fn3 eq i segstart ne and {  % FNC3
                        /i i 1 add def
                        /mode C def
                        /inmac 0 def
                        /segstart i def
                        /segend i UntilEndSeg i get add def
                    } if
                    /i i 1 add def
                    exit
                } if
                [ Avals msg i get get ] addtocws
                /i i 1 add def
                exit
            } if
            Binary i get {  % Binary
                DatumA i 1 add get {
                    msg i get 160 lt {
                        [ Avals bsa get Avals msg i get 128 sub get ] addtocws
                    } {
                        [ Avals bsb get Bvals msg i get 128 sub get ] addtocws
                    } ifelse
                    /i i 1 add def
                    exit
                } if
                [ Avals bin get ] addtocws
                /mode BIN def
                exit
            } if
            /n AheadB i get def
            n 6 gt {
                [ Avals lab get ] addtocws
                /mode B def
                exit
            } if
            [ Avals [ sfb sb2 sb3 sb4 sb5 sb6 ] n 1 sub get get ] addtocws
            n {
                [ Bvals msg i get get ] addtocws
                /i i 1 add def
            } repeat
            exit
        } repeat
    } bind def

    /encBIN {
        1 {  % Common exit
            /n TryC i get def
            n 2 ge {
                [ finaliseBIN ] addtocws
                n 7 gt {  % Terminate to C
                    [ BINvals tmc get ] add
                    /mode C def
                    exit
                } if
                [ BINvals [ sc2 sc3 sc4 sc5 sc6 sc7 ] n 2 sub get get ] addtocws
                n {
                    msg i get 0 lt {
                        [ Cvals msg i get get ] addtocws
                        /i i 1 add def
                    } {
                        [ msg i get 48 sub 10 mul msg i 1 add get 48 sub add ] addtocws
                        /i i 2 add def
                    } ifelse
                } repeat
                exit
            } if
            ECI i get Binary i 7 add get and {  % ECI then binary
                [ ECIbin ] addtocws
                /i i 7 add def
                i msglen eq { [ finaliseBIN ] addtocws } if
                exit
            } if
            msg i get 0 ge {  % Not FNCx
                Binary i       get    Binary i 1 add get or
                Binary i 2 add get or Binary i 3 add get or
                ECI i 1 add get       Binary i 8 add get and or {
                    [ msg i get addtobin ] addtocws
                    /i i 1 add def
                    i msglen eq { [ finaliseBIN ] addtocws } if
                    exit
                } if
            } if
            [ finaliseBIN ] addtocws
            i msglen 1 sub ne {  % Not last character
                msg i get fn3 eq i segstart ne and {  % FNC3
                    [ BINvals tms get ] addtocws
                    /i i 1 add def
                    /mode C def
                    /inmac 0 def
                    /segstart i def
                    /segend i UntilEndSeg i get add def
                    exit
                } if
                AheadA i get AheadB i get gt {
                    [ BINvals tma get ] addtocws
                    /mode A def
                } {
                    [ BINvals tmb get ] addtocws
                    /mode B def
                } ifelse
                exit
            } if
            exit
        } repeat
    } bind def

    /cws barlen 2 mul 1 add array def
    /mode C def
    /bvals 5 array def  /bpos 0 def
    /inmac 0 def  /segstart 0 def  /segend UntilEndSeg 0 get def
    /i 0 def  /j 0 def  {
        i msglen ge {exit} if
        inmac 0 ne {  % Jump over macro trailers
            inmac mac ne i segend 2 sub eq and {  % {RS}{EOT}
                /i i 2 add def
                i msglen ge {exit} if
            } if
            inmac mac eq i segend 1 sub eq and {  % {EOT}
                /i i 1 add def
                i msglen ge {exit} if
            } if
        } if
        [ /encA /encB /encC /encBIN ] mode get load exec
    } loop
    /cws cws 0 j getinterval def

    % Determine the symbol size
    /nd cws length def
    /minarea nd 3 add nd 2 idiv add 9 mul 2 add 2 mul def
    ratio -1 ne {        % Fixed ratio
        /hgt minarea ratio div sqrt def
        /wid minarea ratio mul sqrt def
        /h hgt cvi def  /w wid cvi def
        h w add 2 mod 1 eq {
            h w mul minarea lt {/h h 1 add def  /w w 1 add def} if
        } {
            hgt w mul wid h mul lt {
                /w w 1 add def
                h w mul minarea lt {
                    /w w 1 sub def  /h h 1 add def
                    h w mul minarea lt {/w w 2 add def} if
                } if
            } {
                /h h 1 add def
                h w mul minarea lt {
                    /h h 1 sub def  /w w 1 add def
                    h w mul minarea lt {/h h 2 add def} if
                } if
            } ifelse
        } ifelse
        /rows h def  /columns w def
    } {
        columns -1 eq {  % Fixed height
            /columns minarea rows add 1 sub rows idiv dup rows add 2 mod 0 eq {1 add} if def
        } if
        rows -1 eq {     % Fixed width
            /rows minarea columns add 1 sub columns idiv dup columns add 2 mod 0 eq {1 add} if def
        } if
    } ifelse

rows    10 10 string cvrs print (,) print
columns 10 10 string cvrs print (,) print
cws {10 10 string cvrs print ( ) print} forall (,) print

    % Extend the codewords with padding
    /ndots rows columns mul 2 idiv def
    {
        nd 1 add dup 2 idiv 3 add add 9 mul 2 add ndots gt {exit} if
        /nd nd 1 add def
    } loop
    /nc nd 2 idiv 3 add def
    /nw nd nc add def
    /rembits ndots nw 9 mul 2 add sub def
    nd cws length gt {
        /cws [
            cws aload pop
            mode BIN eq {109} {106} ifelse
            nd cws length sub 1 sub {106} repeat
        ] def
    } if

    % Create an array containing the character mappings
    /encs [
        (101010101) (010101011) (010101101) (010110101) (011010101)
        (101010110) (101011010) (101101010) (110101010) (010101110)
        (010110110) (010111010) (011010110) (011011010) (011101010)
        (100101011) (100101101) (100110101) (101001011) (101001101)
        (101010011) (101011001) (101100101) (101101001) (110010101)
        (110100101) (110101001) (001010111) (001011011) (001011101)
        (001101011) (001101101) (001110101) (010010111) (010011011)
        (010011101) (010100111) (010110011) (010111001) (011001011)
        (011001101) (011010011) (011011001) (011100101) (011101001)
        (100101110) (100110110) (100111010) (101001110) (101011100)
        (101100110) (101101100) (101110010) (101110100) (110010110)
        (110011010) (110100110) (110101100) (110110010) (110110100)
        (111001010) (111010010) (111010100) (001011110) (001101110)
        (001110110) (001111010) (010011110) (010111100) (011001110)
        (011011100) (011100110) (011101100) (011110010) (011110100)
        (100010111) (100011011) (100011101) (100100111) (100110011)
        (100111001) (101000111) (101100011) (101110001) (110001011)
        (110001101) (110010011) (110011001) (110100011) (110110001)
        (111000101) (111001001) (111010001) (000101111) (000110111)
        (000111011) (000111101) (001001111) (001100111) (001110011)
        (001111001) (010001111) (011000111) (011100011) (011110001)
        (100011110) (100111100) (101111000) (110001110) (110011100)
        (110111000) (111000110) (111001100)
    ] def

    % Final six dots arranged at edges
    rows 2 mod 0 eq {
        /sixedges [
            [ columns 1 sub  rows 2 sub ]
            [ 0              rows 2 sub ]
            [ columns 2 sub  rows 1 sub ]
            [ 1              rows 1 sub ]
            [ columns 1 sub  0          ]
            [ 0              0          ]
        ] def
    } {
        /sixedges [
            [ columns 2 sub  0          ]
            [ columns 2 sub  rows 1 sub ]
            [ columns 1 sub  1          ]
            [ columns 1 sub  rows 2 sub ]
            [ 0              0          ]
            [ 0              rows 1 sub ]
        ] def
    } ifelse

    /dmv {columns mul add} bind def

    % Construct the template
    /outline rows columns mul array def
    0 1 rows 1 sub {
        /y exch def
        0 1 columns 1 sub {
            /x exch def
            outline x y dmv x y add 2 mod 1 sub put
        } for
    } for
    sixedges {
        outline exch aload pop dmv 1 put
    } forall

    % Evaluate the symbol
    /evalsymbol {
        /sym exch def

        /pen 0 def  /p 0 def
        rows 2 mod 1 eq {
            /xy /x def  /rc /rows def     /cr /columns def
        } {
            /xy /y def  /rc /columns def  /cr /rows def
        } ifelse
        rc load 12 lt {
            /sum 0 def
            1 1 cr load 2 sub {
                xy exch def
                false
                xy load 1 and 2 rc load 1 sub {
                    xy load xy /x eq {exch} if
                    sym 3 1 roll
                    dmv get 1 eq {pop true exit} if
                } for
                {  % Column/Row not empty
                    /sum 0 def
                    /pen pen p add def
                    /p 0 def
                } {
                    /sum sum 1 add def
                    /p sum 1 eq {rc load} {p rc load mul} ifelse def
                } ifelse
            } for
        } if
        /pen pen p add def

        /worst 9999999 def
        [ [ /x 0 ] [ /x 1 ] [ /y 0 ] [ /y 1 ] ] {  % Top Bottom Left Right
            aload pop  /fl exch def  /dir exch def
            /sum 0 def  /first -1 def  /last -1 def
            0 1 dir /x eq {columns} {rows} ifelse 1 sub {
                dir exch def
                sym
                dir load
                dir /x eq {rows} {columns} ifelse 1 sub fl mul
                dir /y eq {exch} if
                dmv get 1 eq {
                    first -1 eq {/first dir load def} if
                    /last dir load def
                    /sum sum 1 add def
                } if
            } for
            sum last add first sub
            dir /x eq {rows} {columns} ifelse mul
            dup worst lt {/worst exch def} {pop} ifelse
        } forall

        % Pad twice on all sides
        /symp [
            columns 4 add 2 mul {0} repeat
            0 columns sym length 1 sub {
                0 exch 0 exch
                sym exch columns getinterval aload pop
                0 0
            } for
            columns 4 add 2 mul {0} repeat
        ] def

        % Count voids and isolated dots
        /columns columns 4 add def
        /rows    rows    4 add def
        /sum 0 def
        2 1 rows 3 sub {
            /y exch def
            y 1 and 2 add 2 columns 3 sub {
                /x exch def
                1 {  % Common exit
                    symp x 1 sub y 1 sub dmv get 1 eq {exit} if
                    symp x 1 add y 1 sub dmv get 1 eq {exit} if
                    symp x 1 sub y 1 add dmv get 1 eq {exit} if
                    symp x 1 add y 1 add dmv get 1 eq {exit} if
                    symp x y dmv get 0 eq {/sum sum 1 add def exit} if
                    symp x 2 sub y       dmv get 1 eq {exit} if
                    symp x       y 2 sub dmv get 1 eq {exit} if
                    symp x 2 add y       dmv get 1 eq {exit} if
                    symp x       y 2 add dmv get 1 eq {exit} if
                    /sum sum 1 add def
                } repeat
            } for
        } for
        /columns columns 4 sub def
        /rows    rows    4 sub def

worst sum sum mul sub pen sub          10 10 string cvrs print (,) print

% Harsh edge penalty
%
/epen 0 def
0 sym 0 columns getinterval {add} forall 0 eq                         {/epen epen 100000 add def} if
0 sym sym length columns sub columns getinterval {add} forall 0 eq    {/epen epen 200000 add def} if
0  0 columns sym length 1 sub {sym exch get add} for 0 eq             {/epen epen 400000 add def} if
0  columns 1 sub columns sym length 1 sub {sym exch get add} for 0 eq {/epen epen 800000 add def} if
worst sum sum mul sub pen sub epen sub 10 10 string cvrs print (,) print

        worst sum sum mul sub pen sub

    } bind def

    % Reed Solomon antilog table
    /rsalog [ 1 112 { dup 3 mul 113 mod } repeat ] def
    /step nw 112 idiv 1 add def
    /offset {step mul start add} bind def

% TEST: Lit-corner masks
/litmasks 4 array def

    /bestscore -99999999 def
    mask -1 ne { [ mask ] } { [ 2#00 2#01 2#10 2#11 ] } ifelse
    {  % For each mask pattern

        /mask exch def

        % Calculate the error correction codewords for each block
        /rscws [
             mask
             [ 0 3 7 17 ] mask get 0 cws {1 index add 113 mod exch 2 index add exch 3 1 roll} forall pop pop
             nc {0} repeat
        ] def
        0 1 step 1 sub {
            /start exch def
            /ND nd 1 add start sub step add 1 sub step idiv def
            /NW nw 1 add start sub step add 1 sub step idiv def
            /NC NW ND sub def
            /coeffs [ 1 NC {0} repeat ] def
            1 1 NC {
                /i exch def
                NC -1 1 {
                    /j exch def
                    coeffs j coeffs j get 113 add rsalog i get coeffs j 1 sub get mul 113 mod sub 113 mod put
                } for
            } for
            0 1 ND 1 sub {
                /t exch rscws exch offset get rscws ND offset get add 113 mod def
                0 1 NC 2 sub {
                    /j exch def
                    rscws ND j add offset rscws ND j add 1 add offset get 113 add t coeffs j 1 add get mul 113 mod sub 113 mod put
                } for
                rscws ND NC add 1 sub offset 113 t coeffs NC get mul 113 mod sub 113 mod put
            } for
            ND 1 NW 1 sub { dup rscws exch offset 113 rscws 5 -1 roll offset get sub 113 mod put } for
        } for

        % Create the bitstream
        /bits ndots string def
        bits 0 [ (00) (01) (10) (11) ] mask get putinterval
        1 1 nw {
            /i exch def
            bits i 1 sub 9 mul 2 add encs rscws i get get putinterval
        } for
        rembits 0 gt {
            bits nw 9 mul 2 add (11111111111111111) 0 rembits getinterval putinterval
        } if

        % Walk the symbol placing the bitstream
        /pixs outline dup length array copy def
        /posx 0 def
        /posy rows 2 mod 0 eq {0} {rows 1 sub} ifelse def
        bits 0 bits length 6 sub getinterval {
            {  % Move to next vacant position
                pixs posx posy dmv get -1 eq {exit} if
                rows 2 mod 0 eq {
                    /posy posy 1 add def
                    posy rows eq {
                        /posy 0 def
                        /posx posx 1 add def
                    } if
                } {
                    /posx posx 1 add def
                    posx columns eq {
                        /posx 0 def
                        /posy posy 1 sub def
                    } if
                } ifelse
            } loop
            pixs posx posy dmv 3 -1 roll 48 sub put
        } forall
        0 1 5 {  % Last six edge dots
            /i exch def
            pixs sixedges i get aload pop dmv
            bits bits length 6 sub i add get 48 sub put
        } for

% TEST: Make a copy with lit edges for later evaluation
/litmask pixs dup length array copy def
0 1 5 {  % Light last six edge dots
    /i exch def
    litmask sixedges i get aload pop dmv
    1 put
} for
litmasks mask litmask put

        % Evaluate the symbol to find the most suitable mask
        /score pixs evalsymbol def
        score bestscore gt {
            /bestsym pixs def
            /bestscore score def
            fast bestscore rows columns mul 2 idiv gt and {exit} if
        } if

    } forall
    /pixs bestsym def

% TEST: Recalculate with lit corner masks
%bestscore rows columns mul 2 idiv lt {
true {
    /bestscore -99999999 def
    0 1 3 {
        /i exch def
        /litmask litmasks i get def
        /score litmask evalsymbol def
        score bestscore gt {
            /bestsym litmask def
            /bestscore score def
            fast bestscore rows columns mul 2 idiv gt and {exit} if
        } if
    } for
} if

(\n) print

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx columns
    /pixy rows
    /height rows 72 div
    /width columns 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/dotcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource

/next <<
  ALPHABET {dup} forall
  counttomark -1 roll -1 exch -1 exch
>> def

/inc {
  2 dict begin
  /i exch def  /l i length def
  l 0 eq {
    1 string dup 0 next -1 get put
  } {
    i l 1 sub get next exch get dup -1 ne {
       i dup l 1 sub 4 -1 roll put
    } {
      pop
      i 0 l 1 sub getinterval inc dup length 1 add string dup
      0 4 -1 roll putinterval dup
      dup length 1 sub next -1 get put
    } ifelse
  } ifelse
  end
} bind def


/bc START dup length string copy def

ROUNDS {

  bc print (,) print

  bc
  (rows=7 dontdraw parsefnc)
  /dotcode
  /uk.co.terryburton.bwipp findresource exec
  pop

  /bc bc STEP {inc} repeat def

} repeat

